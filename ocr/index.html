<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Captura OCR desde cÃ¡mara en vivo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { font-family: sans-serif; padding: 1rem; background: #111; color: #fff; text-align: center; }
    video, canvas { width: 100%; max-width: 480px; border: 2px solid #ccc; border-radius: 10px; }
    #guia {
      position: absolute; top: 50%; left: 50%; width: 250px; height: 80px;
      transform: translate(-50%, -50%); border: 2px dashed red; box-sizing: border-box; pointer-events: none;
    }
    #contenedorCamara { position: relative; display: inline-block; }
    #estadoOCR, #estadoSend { margin: 1rem 0; font-weight: bold; }
    button {
      padding: 10px 20px; font-size: 1rem; margin-top: 1rem;
      border-radius: 8px; border: none; background-color: #00c853; color: white; cursor: pointer;
    }
    button:disabled { opacity: .6; cursor: not-allowed; }
    input[type="text"] {
      width: 100%; max-width: 320px; padding: .6rem .8rem;
      border-radius: 8px; border: 1px solid #444; background: #000; color: #fff;
    }
  </style>
</head>
<body>

  <h2>Captura de Placa (CÃ¡mara en Vivo)</h2>

  <div id="contenedorCamara">
    <video id="video" autoplay muted playsinline></video>
    <div id="guia"></div>
  </div>

  <button id="btnCapturar" disabled>ðŸ“¸ Capturar</button>

  <p id="estadoOCR">Cargando cÃ¡maraâ€¦</p>
  <input type="text" id="resultadoPlaca" placeholder="Placa detectada..." />

  <!-- Confirmar -->
  <div>
    <button id="btnConfirmar">âœ… Confirmar y enviar</button>
  </div>
  <p id="estadoSend">Esperando confirmaciÃ³nâ€¦</p>

  <canvas id="canvas" style="display:none;"></canvas>

  <script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const estadoOCR = document.getElementById('estadoOCR');
    const estadoSend = document.getElementById('estadoSend');
    const inputPlaca = document.getElementById('resultadoPlaca');
    const btnCapturar = document.getElementById('btnCapturar');
    const btnConfirmar = document.getElementById('btnConfirmar');
    const ctx = canvas.getContext('2d');

    // âš ï¸ Para producciÃ³n, ideal mover este token al backend.
    const API_TOKEN = '3f8ef072e79205794e226ac4c63907d1b081c500';

    // ðŸ‘‰ NUEVO: aquÃ­ guardamos EXACTAMENTE la foto que se manda a PR
    let imagenOCRCapturada = "";

    // ==== CÃ¡mara ====
    async function iniciarCamara() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
        video.srcObject = stream;
        video.addEventListener('loadedmetadata', () => {
          if (video.videoWidth && video.videoHeight) {
            btnCapturar.disabled = false;
            estadoOCR.textContent = 'CÃ¡mara activa. Enfoca la placa en el rectÃ¡ngulo y presiona Capturar.';
          }
        });
      } catch (err) {
        console.error('No se pudo acceder a la cÃ¡mara:', err);
        estadoOCR.textContent = 'Error al acceder a la cÃ¡mara âŒ';
      }
    }
    iniciarCamara();

    // Utilidades
    const normalizar = s => String(s || '').toUpperCase().replace(/[^A-Z0-9]/g, '');

    // â€”â€” helpers de imagen para el pendiente â€”â€”
    function snapshotDeVideo(videoEl) {
      const c = document.createElement('canvas');
      const w = videoEl.videoWidth || videoEl.clientWidth || 640;
      const h = videoEl.videoHeight || videoEl.clientHeight || 480;
      c.width = w; c.height = h;
      c.getContext('2d').drawImage(videoEl, 0, 0, w, h);
      return c.toDataURL('image/jpeg', 0.8); // data:image/jpeg;base64,...
    }
    function imagenActualParaPendiente(videoEl, canvasEl) {
      try { if (videoEl && videoEl.readyState >= 2) return snapshotDeVideo(videoEl); } catch {}
      try {
        if (canvasEl && canvasEl.width && canvasEl.height) {
          return canvasEl.toDataURL('image/jpeg', 0.8);
        }
      } catch {}
      return '';
    }

    // ==== Capturar y reconocer (PlateRecognizer) ====
    btnCapturar.addEventListener('click', async () => {
      // Dibuja frame completo (tu base original)
      canvas.width = video.videoWidth || 640;
      canvas.height = video.videoHeight || 360;
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      estadoOCR.textContent = 'Procesando imagen...';

      canvas.toBlob(async (blob) => {
        // ðŸ‘‰ NUEVO: convertir EL MISMO blob a dataURL y guardarlo
        try {
          const fr = new FileReader();
          fr.onload = () => { imagenOCRCapturada = fr.result; }; // data:image/jpeg;base64,...
          fr.readAsDataURL(blob);
        } catch {}

        const formData = new FormData();
        formData.append('upload', blob, 'captura.jpg');
        formData.append('regions', 'mx');
        formData.append('detection_detail', 'true');
        formData.append('camera_id', 'camara-viva');
        formData.append('config', JSON.stringify({
          blur: true, vehicle_detection: true, multiple_plates: false, country: 'mx', detect_region: true
        }));

        try {
          const res = await fetch('https://api.platerecognizer.com/v1/plate-reader/', {
            method: 'POST', headers: { Authorization: `Token ${API_TOKEN}` }, body: formData
          });

          const data = await res.json();
          console.log('Respuesta PlateRecognizer:', data);

          const resultado = data.results?.[0];

          if (resultado) {
            const placa = normalizar(resultado.plate);
            const score = Number(resultado.score || 0);
            inputPlaca.value = placa;

            if (score < 0.85) {
              estadoOCR.textContent = `Duda en lectura âš ï¸ (${placa}). Corrige y CONFIRMA.`;
            } else {
              estadoOCR.textContent = `Placa detectada âœ… (${placa}). Revisa y CONFIRMA.`;
            }
          } else {
            estadoOCR.textContent = 'No se detectÃ³ placa âŒ';
            inputPlaca.value = '';
          }

        } catch (err) {
          console.error('Error con PlateRecognizer:', err);
          estadoOCR.textContent = 'Error al procesar imagen âŒ';
        }
      }, 'image/jpeg', 0.9); // mantener mismo formato/calidad que PR
    });

    // ==== Confirmar y enviar a /api/pendientes (con anti-duplicados) ====
    let enviando = false;
    let _ultima = { placa:'', t:0 };

    async function existePendiente(placa) {
      try {
        const r = await fetch('/api/pendientes', { cache: 'no-store' });
        const data = await r.json();
        if (!r.ok) return false;
        const lista = Array.isArray(data.data) ? data.data : [];
        return lista.some(x => String(x.placa || '').toUpperCase() === placa);
      } catch { return false; }
    }

    btnConfirmar.addEventListener('click', async () => {
      const placa = normalizar(inputPlaca.value);
      if (!placa || placa.length < 5) {
        estadoSend.textContent = 'Placa invÃ¡lida. Corrige antes de enviar.'; return;
      }
      // Debounce: evita el doble envÃ­o de la misma placa en 5s
      const ahora = Date.now();
      if (_ultima.placa === placa && (ahora - _ultima.t) < 5000) {
        estadoSend.textContent = `Ya enviaste ${placa} hace poco.`; return;
      }
      // Chequeo contra la cola actual
      if (await existePendiente(placa)) {
        estadoSend.textContent = `Omitido: ${placa} ya estÃ¡ en pendientes.`; inputPlaca.value = ''; return;
      }

      if (enviando) return;
      enviando = true; btnConfirmar.disabled = true;

      try {
        estadoSend.textContent = 'Enviandoâ€¦';
        // ðŸ‘‰ NUEVO: usar LA MISMA foto que se mandÃ³ a PR (con fallback suave)
        const imagen = imagenOCRCapturada || imagenActualParaPendiente(video, canvas);

        const r = await fetch('/api/pendientes', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ placa, imagen }) // antes era solo { placa }
        });
        const data = await r.json();
        if (!r.ok) throw new Error(data?.msg || 'Error al enviar');

        try { localStorage.setItem('placaDetectadaOCR', placa); } catch {}
        _ultima = { placa, t: ahora };
        inputPlaca.value = ''; // limpia para evitar reenvÃ­o accidental
        estadoSend.textContent = `Enviado âœ“ (${placa}). Permanece en OCR.`;
      } catch (e) {
        console.error(e);
        estadoSend.textContent = 'No se pudo enviar la placa: ' + e.message;
      } finally {
        enviando = false; btnConfirmar.disabled = false;
      }
    });

    // UX: mayÃºsculas sin caracteres raros
    inputPlaca.addEventListener('input', e => {
      e.target.value = normalizar(e.target.value);
    });
  </script>
</body>
</html>
